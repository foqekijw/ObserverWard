import sys
from typing import Optional, Dict, Tuple, Any
from rich.console import Console, Group
from rich.text import Text
from rich.live import Live
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt
from rich.table import Table

# Initialize Console
try:
    console = Console(emoji=False, force_terminal=True, color_system="truecolor")
except Exception:
    class FallbackConsole:
        @staticmethod
        def print(*args, **kwargs):
            __built_in_print = __builtins__['print'] if isinstance(__builtins__, dict) else __builtins__.print
            __built_in_print(*args, **kwargs)
        def rule(self, *args, **kwargs): pass
        def clear(self): pass
        
    console = FallbackConsole()

def get_key() -> str:
    """Captures a single key press, supporting arrows on Windows."""
    try:
        import msvcrt
        ch = msvcrt.getwch()
        if ch in ("\x00", "\xe0"):
            ch2 = msvcrt.getwch()
            return ch + ch2
        return ch
    except Exception:
        return input().strip()

def show_settings_menu(config: Any, live: Optional[Live] = None) -> None:
    """Interactive settings menu with arrow key navigation."""
    settings = [
        ("1", "Silent Mode", "silent_mode", bool),
        ("2", "Disable Cache", "disable_cache", bool),
        ("3", "Strict Interval", "strict_interval", bool),
        ("4", "Screenshot Width", "screenshot_width", int),
        ("5", "Screenshot Height", "screenshot_height", int),
        ("6", "Monitor Index", "screenshot_monitor_index", int),
    ]
    
    idx = 0
    local_live = False
    
    if not live:
        try:
            live = Live(refresh_per_second=12, console=console, transient=True)
            live.__enter__()
            local_live = True
        except Exception:
            live = None
        
    nav_line = "[dim]↑↓ — select · Enter — toggle/edit · q — back[/dim]"
    
    try:
        while True:
            table = Table(title="[bold cyan]Settings[/bold cyan]", show_header=True, header_style="bold magenta")
            table.add_column("Key", style="dim", width=4)
            table.add_column("Setting", width=30)
            table.add_column("Value", width=20)
            
            for i, (key, name, attr, type_) in enumerate(settings):
                val = getattr(config, attr)
                row_style = "reverse" if i == idx else None
                table.add_row(key, name, str(val), style=row_style)
            
            if live:
                try:
                    live.update(Group(table, Text(nav_line)))
                except Exception:
                    getattr(console, "clear", lambda: None)()
                    console.rule()
                    console.print(table)
            else:
                getattr(console, "clear", lambda: None)()
                console.rule()
                console.print(table)
                console.print(nav_line)
            
            key = get_key()
            
            if key in ("\xe0H", "\x1b[A", "\x1bOA"): # Up
                idx = max(0, idx - 1)
                continue
            if key in ("\xe0P", "\x1b[B", "\x1bOB"): # Down
                idx = min(len(settings) - 1, idx + 1)
                continue
            
            if key.lower() == 'q':
                break
                
            if key in ("\r", "\n", "\r\n"):
                _, name, attr, type_ = settings[idx]
                current_val = getattr(config, attr)
                
                if type_ == bool:
                    setattr(config, attr, not current_val)
                elif type_ == int:
                    # For input, we might need to pause live if we want standard input
                    # But IntPrompt works with console.
                    # If we are in Live(screen=True), input might be tricky if not handled carefully.
                    # We'll stop live briefly for input if needed, or just rely on Rich's prompt handling.
                    if live: live.stop()
                    try:
                        val = IntPrompt.ask(f"Enter new {name}", default=current_val)
                        setattr(config, attr, val)
                    except Exception: pass
                    if live: live.start()
    finally:
        if local_live and live:
            try:
                live.__exit__(None, None, None)
            except Exception:
                pass

def show_menu(styles: Dict[str, Tuple[str, str]], config: Any) -> Tuple[Optional[Tuple[str, str]], int]:
    """Interactive menu to select style and interval."""
    if not styles:
        return None, config.interval_seconds

    keys = list(styles.keys())
    idx = 0
    
    try:
        # Use screen=True to use alternate screen buffer (no history pollution)
        live = Live(refresh_per_second=12, console=console, screen=True)
        live.__enter__()
    except Exception:
        live = None
        
    nav_line = "[dim]↑↓ — select · Enter — confirm · 9 — settings · q — quit[/dim]"
    
    try:
        while True:
            table = Table(title="[bold cyan]Available Styles[/bold cyan]", show_header=True, header_style="bold magenta")
            table.add_column("#", style="dim", width=4)
            table.add_column("Style", width=32, overflow='fold')
            
            for i, k in enumerate(keys):
                name = styles[k][0]
                if i == idx:
                    table.add_row(f">{k}", f"[reverse]{name}[/reverse]")
                else:
                    table.add_row(k, name)

            if live:
                try:
                    live.update(Group(table, Text(nav_line)))
                except Exception:
                    getattr(console, "clear", lambda: None)()
                    console.rule()
                    console.print(table)
            else:
                getattr(console, "clear", lambda: None)()
                console.rule()
                console.print(table)
                console.print(nav_line)

            key = get_key()
            
            if key in ("\xe0H", "\x1b[A", "\x1bOA"): # Up
                idx = max(0, idx - 1)
                continue
            if key in ("\xe0P", "\x1b[B", "\x1bOB"): # Down
                idx = min(len(keys) - 1, idx + 1)
                continue
            if key in ("\r", "\n", "\r\n"):
                selected_key = keys[idx]
                selected_style = styles[selected_key]
                break
                
            if isinstance(key, str) and key.lower() == 'q':
                return None, config.interval_seconds
                
            if key == '9':
                show_settings_menu(config, live)
                # When returning, loop continues and updates live with styles table again
                continue
            
            # Direct numeric entry
            try:
                s = str(key).strip()
                if s in styles:
                    selected_key = s
                    selected_style = styles[selected_key]
                    break
            except Exception:
                pass
    finally:
        if live:
            try:
                live.__exit__(None, None, None)
            except Exception:
                pass

    # Interval selection - outside of Live context
    try:
        interval = IntPrompt.ask("\n[yellow]Enter interval (seconds)[/yellow]", default=config.interval_seconds)
    except Exception:
        interval = config.interval_seconds
        
    return selected_style, interval
